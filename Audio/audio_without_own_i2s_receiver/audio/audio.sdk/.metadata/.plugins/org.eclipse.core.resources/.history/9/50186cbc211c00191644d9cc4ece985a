/*
 * spi_driver.c
 *
 *  Created on: 06.01.2019
 *      Author: Jannes
 */

//todo umbenennen in audau spi driver
#include <fcntl.h>
#include <unistd.h>
#include "SPI_Driver.h"
#include <stdio.h>


static volatile spi *const spi_port = (spi*) (QUAD_SPI_BASE_ADDRESS + QUAD_SPI_OFFSET);


void check_addresses(){
	printf("check addresses\n");
	printf("SPI_REGS BASE: 0x%x\n", spi_port);
	printf("IPISR ADDRESS: 0x%x\n", &spi_port->IPISR);
	printf("SRR ADDRESS: 0x%x\n", &spi_port->SRR);
	printf("SPICR ADDRESS: 0x%x\n", &spi_port->SPICR);
	printf("SPISR ADDRESS: 0x%x\n", &spi_port->SPISR);
	printf("DTR ADDRESS: 0x%x\n", &spi_port->SPI_DTR);
	printf("DRR ADDRESS: 0x%x\n", &spi_port->SPI_DDR);
	printf("SPISSR ADDRESS: 0x%x\n", &spi_port->SPISSR);

}

void print_regs(){
	printf("print_regs:\n");
	printf("IPISR: 0x%x\n", spi_port->IPISR);
	printf("SPICR: 0x%x\n", spi_port->SPICR);
	printf("SPISR: 0x%x\n", spi_port->SPISR);
	printf("SPISSR: 0x%x\n", spi_port->SPISSR);
}

void check_rx_tx(){
	printf("check rx_tx\n");
	unsigned int* led_base = GPIO_BASE_ADDRESS;
	if (spi_port->SPISR & SPI_RX_FULL) {
		*led_base = 0x1;
	}
	else{
		*led_base = 0x0;
	}
}

/**
 * initializes the spi, to be done before trying to read or write any data
 * */
void spi_initialize() {

	printf("spi_initialize\n");
	spi_port->SPICR = SPI_CONTROL_REGISTER_DEFAULT;
	spi_port->SPISSR = SPI_SS_DEFAULT;
}

void spi_reset() {
    spi_port->SRR = SPI_RESET_CONSTANT;
}

/*void _spi_transfer(uint8_t* sendbuffer, uint8_t*recbuffer, int len, uint8_t command, uint16_t address){
    uint8_t setup_data[3];
    setup_data[0] = command;
    setup_data[1] = address >> 8;
    setup_data[2] = address;

    spi_port->SPI_DTR = setup_data[0];
    spi_port->SPICR = SPI_CONTROL_REGISTER_DEFAULT;
    spi_port->SPISSR = SPI_SS;
    spi_port->SPICR = spi_port->SPICR ^ SPI_INHIBIT_TRANSACTION;

	for (int i = 1; i < len + 3; i++){
		while ((spi_port->IPISR & SPI_DTR_EMPTY) != SPI_DTR_EMPTY);
		spi_port->IPISR = spi_port->IPISR | SPI_DTR_EMPTY;
		spi_port->SPICR = spi_port->SPICR | SPI_INHIBIT_TRANSACTION;
		if (i < 3) {
			recbuffer[i-1] = spi_port->SPI_DDR;
			spi_port->SPI_DTR = setup_data[i];
			spi_port->SPICR = spi_port->SPICR ^ SPI_INHIBIT_TRANSACTION;
		}
		else {
			recbuffer[i-1] = spi_port->SPI_DDR;
			spi_port->SPI_DTR = sendbuffer[i-3];
			spi_port->SPICR = spi_port->SPICR ^ SPI_INHIBIT_TRANSACTION;
		}
	}
	while ((spi_port->IPISR & SPI_DTR_EMPTY) != SPI_DTR_EMPTY);
	spi_port->IPISR = spi_port->IPISR | SPI_DTR_EMPTY;
	spi_port->SPICR = spi_port->SPICR | SPI_INHIBIT_TRANSACTION;
	recbuffer[len + 3 - 1] = spi_port->SPI_DDR;

    spi_port->SPISSR = SPI_SS_DEFAULT;
    spi_port->SPICR = SPI_CONTROL_REGISTER_DEFAULT;
}*/

/**
 * Transactions require to transmit a command and an address, spi core must not be enabled beforehand
 * @param buffer
 * @param address
 * */
void _spi_send_command_and_address(uint8_t command, unsigned int address) {
    int setup_length = 3; // command read or write(1 byte) + address(2 bytes) = 3 bytes
    uint8_t transmit_data[setup_length];
    transmit_data[0] = command;
    transmit_data[1] = address >> 8;
    transmit_data[2] = address;

    spi_port->SPI_DTR = transmit_data[0]; // initial data has to be written into the DTR before enabling the spi core

    if (spi_port->SPISSR != SPI_SS_DEFAULT) {
        printf("error slave select not in default mode\n");
        return;
    }

    spi_port->SPICR = SPI_CONTROL_REGISTER_DEFAULT;

    spi_port->SPISSR = SPI_SS;

    spi_port->SPICR = spi_port->SPICR ^ SPI_INHIBIT_TRANSACTION;

    for (int i = 1; i < setup_length; i++) {

    	while ((spi_port->IPISR & SPI_DTR_EMPTY) != SPI_DTR_EMPTY);
    	//printf("byte %d transmission complete transmitted 0x%x!\n", i - 1, transmit_data[i - 1]);
    	spi_port->IPISR = spi_port->IPISR | SPI_DTR_EMPTY;

    	spi_port->SPICR = spi_port->SPICR | SPI_INHIBIT_TRANSACTION;
    	//printf("%d IPISR: 0x%x\n",i - 1 , spi_port->IPISR);

    	spi_port->SPI_DTR = transmit_data[i];

    	spi_port->SPICR = spi_port->SPICR ^ SPI_INHIBIT_TRANSACTION;

    }
    while ((spi_port->IPISR & SPI_DTR_EMPTY) != SPI_DTR_EMPTY);
   // printf("byte %d transmission complete transmitted 0x%x!\n", setup_length - 1, transmit_data[setup_length - 1]);
    spi_port->IPISR = spi_port->IPISR | SPI_DTR_EMPTY;


    spi_port->SPICR = spi_port->SPICR | SPI_INHIBIT_TRANSACTION;
    //printf("%d IPISR: 0x%x\n",setup_length - 1 , spi_port->IPISR);

    unsigned int garbage = spi_port->SPI_DDR;
    //printf("garbage: 0x%x\n",garbage);

    //spi_port->SPISSR = SPI_SS_DEFAULT;
}

/**
 * buffer has to be MSB first -> buffer[length - 1] = MSB
 * writes lenght number of bytes from address into buffer
 * @param buffer
 * @param command
 * @param address
 * @param length
 * */
void spi_write_buffer(uint8_t *buffer, unsigned int address, int length) {

    _spi_send_command_and_address(SPI_WRITE_AUDIO_REG, address);



    for (int i = 0; i < length; i++) {

        spi_port->SPI_DTR = buffer[(length - 1) - i];
        spi_port->SPICR = spi_port->SPICR ^ SPI_INHIBIT_TRANSACTION;
        while ((spi_port->IPISR & SPI_DTR_EMPTY) != SPI_DTR_EMPTY);
        //printf("transmission complete sended 0x%x\n", buffer[(length - 1) - i]);
        spi_port->IPISR = spi_port->IPISR | SPI_DTR_EMPTY;
        spi_port->SPICR = spi_port->SPICR | SPI_INHIBIT_TRANSACTION;
    }

    //clean up: disable spi core, reset SS_REG
    spi_port->SPISSR = SPI_SS_DEFAULT;
    spi_port->SPICR = SPI_CONTROL_REGISTER_DEFAULT;
}


/**
 * reads length number of bytes from address into buffer
 * @param buffer
 * @param command
 * @param address
 * @param length
 * */
void spi_read_buffer(uint8_t *buffer, unsigned int address, int length) {

    _spi_send_command_and_address(SPI_READ_AUDIO_REG, address);
    //printf("returning from command and address send\n");

    for (int i = 0; i < length; i++) {
    	 //garbage write
    	  spi_port->SPI_DTR = 0x0;
    	  spi_port->SPICR = spi_port->SPICR ^ SPI_INHIBIT_TRANSACTION;
    	  while ((spi_port->IPISR & SPI_DTR_EMPTY) != SPI_DTR_EMPTY);
    	  spi_port->IPISR = spi_port->IPISR | SPI_DTR_EMPTY;
    	  spi_port->SPICR = spi_port->SPICR | SPI_INHIBIT_TRANSACTION;
        /* vielleicht muss hier noch einmal das rx ausgelesen werden und danach gewartet werden
         * denn natürlich ist nach senden des command und address schon was in der RX queue */
        while ((spi_port->SPICR & SPI_RX_EMPTY) == SPI_RX_EMPTY){
        	for (int i = 0; i < 100000; i++);
        	printf("try to receive sth..\n");
        };
        buffer[(length - 1) - i] = spi_port->SPI_DDR;
    }

    //clean up: disable spi core, reset SS_REG
    spi_port->SPISSR = SPI_SS_DEFAULT;
    spi_port->SPICR = SPI_CONTROL_REGISTER_DEFAULT;

}

uint8_t spi_read_value(unsigned int address){
	uint8_t buffer[1] = {0x0};
	spi_read_buffer(buffer, address, 1);
	return buffer[0];
}

void spi_write_value(uint8_t value, unsigned int address){
	uint8_t buffer[1] = {value};
	spi_write_buffer(buffer, address, 1);
}
