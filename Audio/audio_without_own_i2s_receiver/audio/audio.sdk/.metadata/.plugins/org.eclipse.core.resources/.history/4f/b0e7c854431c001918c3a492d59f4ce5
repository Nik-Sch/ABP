/*
 * audio_driver.c
 *
 *  Created on: 06.01.2019
 *      Author: Jannes
 */

#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

#include "audio_driver.h"
#include "SPI_Driver.h"


//todo audio std abtippen und tests anlegen vielleicht auch einen loopback test
//todo quad spi manual p.85 Write Operation to SPI In SCK ratio = 2 scenarios, a successful write operation should be completed within two clock cycles of ext_spi_clk.
/**
 * std configuration for the audio chip
 * */
void _audio_std_configuration() { // todo r17 r64? -> depens on the clk todo clk config r0 r1 and what the heck will i put on MCLK
	printf("configuring ADAU1716 registers..");

    // routing line in to mixers
    spi_write_value(0x01, R4_REC_MIXER_L_CTRL_0); // enable mixer 1
    if (spi_read_value(R4_REC_MIXER_L_CTRL_0) != 0x01){
    	printf(" configuring R4 failed\n");
    	return;
    }
    spi_write_value(0x07, R5_REC_MIXER_L_CTRL_1); // unmute left channel of line in into mixer 1 and set gain to 0 db was 0x05 changed 7.1.19
    if (spi_read_value(R5_REC_MIXER_L_CTRL_1) != 0x07){
    	printf(" configuring R5 failed\n");
    	return;
    }
    spi_write_value(0x01, R6_REC_MIXER_R_CTRL_0); // enable mixer 2
    if (spi_read_value(R6_REC_MIXER_R_CTRL_0) != 0x01){
    	printf(" configuring R6 failed\n");
    	return;
    }
    spi_write_value(0x07, R7_REC_MIXER_R_CTRL_1); // unmute right channel of line in into mixer 1 and set gain to 0 db was 0x05 changed 7.1.19
    if (spi_read_value(R7_REC_MIXER_R_CTRL_1) != 0x07){
    	printf(" configuring R7 failed\n");
    	return;
    }
    spi_write_value(0x13, R19_ADC_CTRL); //enable ADCs was 0x03 changed to 0x13 7.1.19
    if (spi_read_value(R19_ADC_CTRL) != 0x13){
    	printf(" configuring R19 failed\n");
    	return;
    }
    // routing to output mixers
    spi_write_value(0x21, R22_PB_MIXER_L_CTRL_0); // unmute left DAC into mixer 3; enable mixer 3; set gain to 0 db was 0x2D changed 7.1.19
    if (spi_read_value(R22_PB_MIXER_L_CTRL_0) != 0x21){
    	printf(" configuring R22 failed\n");
    	return;
    }
    spi_write_value(0x41, R24_PB_MIXER_R_CTRL_0); // unmute right DAC into mixer 4; enable mixer 4; set gain to 0 db was 0x4D changed  7.1.19
    if (spi_read_value(R24_PB_MIXER_R_CTRL_0) != 0x41){
    	printf(" configuring R24 failed\n");
    	return;
    }
    spi_write_value(0x05, R26_PB_LR_MIXER_L_LINE_OUT_CTRL); // unmute mixer 3 into mixer 5 and set gain to 0 db; enable mixer 5 was 0x03 changed 7.1.19
    if (spi_read_value(R26_PB_LR_MIXER_L_LINE_OUT_CTRL) != 0x05){
    	printf(" configuring R26 failed\n");
    	return;
    }
    spi_write_value(0x11, R27_PB_LR_MIXER_R_LINE_OUT_CTRL); // unmute mixer 4 into mixer 6 and set gain to 0 db; enable mixer 6 was 0x09 changed 7.1.19
    if (spi_read_value(R27_PB_LR_MIXER_R_LINE_OUT_CTRL) != 0x11){
    	printf(" configuring R27 failed\n");
    	return;
    }
    int i = 0;
    // config line out mute headphone
    while (spi_read_value(R29_PB_HEADPHONE_L_VOLUME_CTRL)!= 0xFF){
    	spi_write_value(0xFF, R29_PB_HEADPHONE_L_VOLUME_CTRL); // mute left channel of headphone
    	i++;
    	if (i > 100){
    		printf(" configuring R29 failed\n");
    		return;
    	}
    }

    while (spi_read_value(R30_PB_HEADPHONE_R_VOLUME_CTRL)!= 0xFF){
    	spi_write_value(0xFF, R30_PB_HEADPHONE_R_VOLUME_CTRL); // mute left channel of headphone
    	i++;
    	if (i > 100){
    		printf(" configuring R30 failed\n");
    		return;
    	}
    }

    while (spi_read_value(R31_PB_LINE_OUT_L_VOLUME_CTRL)!= 0xFE){
    	spi_write_value(0xFE, R31_PB_LINE_OUT_L_VOLUME_CTRL); // mute left channel of headphone
    	i++;
    	if (i > 100){
    		printf(" configuring R31 failed\n");
    		return;
    	}
    }
    while (spi_read_value(R32_PB_LINE_OUT_R_VOLUME_CTRL)!= 0xFE){
    	spi_write_value(0xFE, R32_PB_LINE_OUT_R_VOLUME_CTRL); // mute left channel of headphone
    	i++;
    	if (i > 100){
    		printf(" configuring R32 failed\n");
    		return;
    	}
    }
    spi_write_value(0x03, R35_PB_POWER_MANAGEMENT); // enable playback right and left channel
    if (spi_read_value(R35_PB_POWER_MANAGEMENT) != 0x03){
    	printf(" configuring R35 failed\n");
    	return;
    }
    spi_write_value(0x03, R36_DAC_CTRL_0); // enable both DACs
    if (spi_read_value(R35_PB_POWER_MANAGEMENT) != 0x03){
    	printf(" configuring R36 failed\n");
    	return;
    }

    //config serial port as master and the routing
	spi_write_value(0x01, R15_SERIAL_PORT_CTRL_0); // set audio chip as master
    if (spi_read_value(R15_SERIAL_PORT_CTRL_0) != 0x01){
    	printf(" configuring R15 failed\n");
    	return;
    }
    spi_write_value(0x01, R58_SERIAL_IN_ROUTE_CTRL); // connect I2S serial port input (SDATA_I) to ADCs
    if (spi_read_value(R58_SERIAL_IN_ROUTE_CTRL) != 0x01){
    	printf(" configuring R58 failed\n");
    	return;
    }
    spi_write_value(0x01, R59_SERIAL_OUT_ROUTE_CTRL); // connect I2S serial port output (SDATA_O) to DACs
    if (spi_read_value(R59_SERIAL_OUT_ROUTE_CTRL) != 0x01){
    	printf(" configuring R59 failed\n");
    	return;
    }
    printf(" DONE!\n");
}

void audio_config_geklaut(){
	printf("configuring ADAU1761 geklaut..");
	spi_write_value(0x01, R4_REC_MIXER_L_CTRL_0);
    if (spi_read_value(R4_REC_MIXER_L_CTRL_0) != 0x01){
    	printf(" configuring R4 failed\n");
    	return;
    }
	spi_write_value(0x08, R5_REC_MIXER_L_CTRL_1);
    if (spi_read_value(R5_REC_MIXER_L_CTRL_1) != 0x08){
    	printf(" configuring R4 failed\n");
    	return;
    }
	spi_write_value(0x63, R8_L_DIFF_IN_VOLUME_CTRL);
    if (spi_read_value(R8_L_DIFF_IN_VOLUME_CTRL) != 0x63){
    	printf(" configuring R4 failed\n");
    	return;
    }
	spi_write_value(0x01, R15_SERIAL_PORT_CTRL_0);
    if (spi_read_value(R15_SERIAL_PORT_CTRL_0) != 0x01){
    	printf(" configuring R15 failed\n");
    	return;
    }
	spi_write_value(0x23, R19_ADC_CTRL);
    if (spi_read_value(R19_ADC_CTRL) != 0x23){
    	printf(" configuring R19 failed\n");
    	return;
    }
    spi_write_value(0x01, R59_SERIAL_OUT_ROUTE_CTRL);
    if (spi_read_value(R59_SERIAL_OUT_ROUTE_CTRL) != 0x01){
    	printf(" configuring R59 failed\n");
    	return;
    }
    printf(" DONE!\n");
}

void audio_std_configuration(){
	printf("configuring ADAU1761 registers for AUX bypass playback and AUX to ADC..");

    spi_write_value(0x01, R4_REC_MIXER_L_CTRL_0);
    if (spi_read_value(R4_REC_MIXER_L_CTRL_0) != 0x01){
    	printf(" configuring R4 failed\n");
    	return;
    }
    spi_write_value(0x07, R5_REC_MIXER_L_CTRL_1);
    if (spi_read_value(R5_REC_MIXER_L_CTRL_1) != 0x07){
    	printf(" configuring R5 failed\n");
    	return;
    }
    spi_write_value(0x01, R6_REC_MIXER_R_CTRL_0);
    if (spi_read_value(R6_REC_MIXER_R_CTRL_0) != 0x01){
    	printf(" configuring R6 failed\n");
    	return;
    }
    spi_write_value(0x07, R7_REC_MIXER_R_CTRL_1);
    if (spi_read_value(R7_REC_MIXER_R_CTRL_1) != 0x07){
    	printf(" configuring R7 failed\n");
    	return;
    }
    spi_write_value(0x23, R19_ADC_CTRL);
	if (spi_read_value(R19_ADC_CTRL) != 0x23){
		printf(" configuring R19 failed\n");
		return;
	}
	spi_write_value(0x01, R15_SERIAL_PORT_CTRL_0);
    if (spi_read_value(R15_SERIAL_PORT_CTRL_0) != 0x01){
    	printf(" configuring R15 failed\n");
        return;
	}
	spi_write_value(0x11, R22_PB_MIXER_L_CTRL_0);
    if (spi_read_value(R22_PB_MIXER_L_CTRL_0) != 0x11){
    	printf(" configuring R22 failed\n");
    	return;
    }

    spi_write_value(0x11, R24_PB_MIXER_R_CTRL_0);
    if (spi_read_value(R24_PB_MIXER_R_CTRL_0) != 0x11){
    	printf(" configuring R24 failed\n");
        return;
    }
    spi_write_value(0x05, R26_PB_LR_MIXER_L_LINE_OUT_CTRL);
    if (spi_read_value(R26_PB_LR_MIXER_L_LINE_OUT_CTRL) != 0x05){
        printf(" configuring R26 failed\n");
        return;
    }
    spi_write_value(0x11, R27_PB_LR_MIXER_R_LINE_OUT_CTRL);
    if (spi_read_value(R27_PB_LR_MIXER_R_LINE_OUT_CTRL) != 0x11){
        printf(" configuring R27 failed\n");
        return;
    }
    spi_write_value(0xFE, R31_PB_LINE_OUT_L_VOLUME_CTRL);
    if (spi_read_value(R31_PB_LINE_OUT_L_VOLUME_CTRL)!= 0xFE){
        printf(" configuring R31 failed\n");
        return;
    }
    spi_write_value(0xFE, R32_PB_LINE_OUT_R_VOLUME_CTRL);
    if (spi_read_value(R32_PB_LINE_OUT_R_VOLUME_CTRL)!= 0xFE){
        printf(" configuring R32 failed\n");
        return;
    }
    spi_write_value(0x03, R35_PB_POWER_MANAGEMENT); // enable playback right and left channel
    if (spi_read_value(R35_PB_POWER_MANAGEMENT) != 0x03){
        printf(" configuring R35 failed\n");
        return;
    }
    spi_write_value(0x01, R59_SERIAL_OUT_ROUTE_CTRL); // enable playback right and left channel
    if (spi_read_value(R59_SERIAL_OUT_ROUTE_CTRL) != 0x01){
        printf(" configuring R59 failed\n");
        return;
    }



	printf(" DONE!\n");
}

void _audio_clk_enable(){
    // enable clks
    spi_write_value(0x7F, R65_CLOCK_ENABLE_0); // enables ALC, dejitter, serial routing out and inputs, serial port clock
    if (spi_read_value(R65_CLOCK_ENABLE_0) != 0x7F){
    	printf(" configuring R65 failed\n");
    	return;
    }
    spi_write_value(0x11, R66_CLOCK_ENABLE_1); // enables the 2 clk generators for ADC DAC DSP and BCLK and LRCLK for serial port was 0x01 changed 7.1.19
    if (spi_read_value(R66_CLOCK_ENABLE_1) != 0x11){
    	printf(" configuring R66 failed\n");
    	return;
    }
}


void _audio_clk_configuration(){
	printf("running audio clk configuration\n");

	// Disable Core Clock take pll
	spi_write_value(0x0E, R0_CLK_CTRL);

	if(spi_read_value(R0_CLK_CTRL) != 0x0E){
		printf("ERROR CONFIGURING R0\n");
		return;
	}

	uint8_t r1_config_buffer[AUDIO_REG_R1_SIZE];
	r1_config_buffer[5]	= 0x0C;
	r1_config_buffer[4]	= 0x35;
	r1_config_buffer[3]	= 0x06;
	r1_config_buffer[2]	= 0x4C;
	r1_config_buffer[1]	= 0x21;
	r1_config_buffer[0]	= 0x01;

	spi_write_buffer(r1_config_buffer, R1_PLL_CTRL, AUDIO_REG_R1_SIZE);

	for (int i = 0; i < AUDIO_REG_R1_SIZE; i++){
		r1_config_buffer[i] = 0;
	}

	unsigned int pll_locked = 0;
	printf("waiting for pll lock..");
	while (pll_locked == 0) {
		printf(".");
		spi_read_buffer(r1_config_buffer, R1_PLL_CTRL, AUDIO_REG_R1_SIZE);
		pll_locked = (r1_config_buffer[0] & PLL_LOCKED_BITMASK);
	}
	printf(" LOCKED!\n");
	spi_write_value(0x0F, R0_CLK_CTRL);
	if(spi_read_value(R0_CLK_CTRL) != 0x0F){
			printf("ERROR CONFIGURING CLK\n");
			return;
		}
	printf("audio clk configuration complete\n");

}

/**
 * initializes audio and spi and calls audio std configuration
 * */
void audio_initialize() {

    spi_initialize();

    // dummy reads to get adau control port in spi mode
    spi_read_value(R0_CLK_CTRL);
    spi_read_value(R0_CLK_CTRL);
    spi_read_value(R0_CLK_CTRL);

    _audio_clk_configuration();
    audio_config_geklaut();
    _audio_clk_enable();




    return;
}

void audio_set_register(uint8_t value, unsigned int address){
	spi_write_value(value, address);
	if (spi_read_value(address) != value){
		printf("FAILED!\n");
	}else{
		printf("DONE!\n");
	}
}

